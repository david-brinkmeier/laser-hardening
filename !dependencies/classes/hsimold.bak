classdef heatSim
    
    properties
        autoUpdate      (1,1) double        % when enabled, automatically update results / temp fields
        heatSourceType  (1,:) char          % point or gaussian; point yields singularities at surface
        
        material              material
        
        xrange          (1,2) double        % start and end, in m
        yrange          (1,1) double        % symmetric about zero, in m
        zrange          (1,:) double        % start and end, in m OR vector explicitly defining positions
        resolutionXY    (1,1) double        % in m
        resolutionZ     (1,1) double        % in m
        vfeed           (:,1) double        % vfeed vector
        power           (1,1) double        % power in W
        
        heatDistrib           heatInputs    % interface for setting heat Distribution
        Results               heatSimResults.container
    end
    
    properties (SetAccess = protected)
        kernelsReady    (1,1) logical
        kernel          (:,1) cell      % array of kernels, one for each vfeed
    end
    
    properties (Dependent)
        index               (1,1) uint32    % selected vfeed index
    end
    
    properties (Dependent, Hidden)
        xvect               (1,:) double
        yvect               (1,:) double
        zvect               (1,:) double
        centerX             (1,1) double
        centerY             (1,1) double
    end
    
    properties (Dependent, Access = private)
        heatScale           (1,1) double    % cline-anthony prefactor; depends on power and material props
        heatScalePTsource   (1,1) double
    end
    
    properties (Access = private)
        index_prv           (1,1) uint32
    end
      
    methods
        
        function obj = heatSim(material)
            if isa(material,'material')
                obj.material = material;
            else
                warning('Material must be supplied.')
            end
            obj.power = 1;
            obj.heatSourceType = 'point';
            obj.autoUpdate = false;
            obj.index = 1;
        end
        
        function obj = set.heatSourceType(obj,val)
            val = lower(val);
            allowed = {'point','gaussian'};
            if ~ismember(val,allowed)
                warning('Invalid type, using "point".')
                fprintf('Allowed types are:\n')
                fprintf('"%s"\n',allowed{:})
                val = 'point';
            end
            obj.heatSourceType = val;
        end
        
        function obj = set.index(obj,val)
           if val < 1
               val = 1;
           elseif val > length(obj.vfeed)
               val = length(obj.vfeed);
           end
           obj.index_prv = val;
           
           if obj.kernelsReady && obj.autoUpdate
               obj = obj.updateResult();
           end
        end
        
        function val = get.index(obj)
            val = obj.index_prv;
        end
        
        function val = get.kernelsReady(obj)
            if ~isempty(obj.kernel)
                val = true;
            else
                val = false;
            end
        end
        
        function obj = set.xrange(obj,val)
            obj.xrange = val;
            obj = obj.reset();
        end
        
        function obj = set.yrange(obj,val)
            obj.yrange = val;
            obj = obj.reset();
        end
        
        function obj = set.zrange(obj,val)
            obj.zrange = val;
            obj = obj.reset();
        end
        
        function obj = set.vfeed(obj,val)
           obj.vfeed = val;
           obj = obj.reset();
        end
        
        function obj = set.resolutionXY(obj,val)
            if isfinite(val)
                obj.resolutionXY = abs(val);
                obj = obj.reset();
            end
        end
        
        function obj = set.resolutionZ(obj,val)
            if isfinite(val)
                obj.resolutionZ = abs(val);
                obj = obj.reset();
            end
        end
                
        function val = get.xvect(obj)
            val = obj.xrange(1):obj.resolutionXY:obj.xrange(2);
            if ~bitget(length(val),1)
                % then length iseven, add one more
                val = [val,val(end)+obj.resolutionXY];
            end
        end
        
        function val = get.yvect(obj)
            val = -obj.yrange:obj.resolutionXY:obj.yrange;
            if ~bitget(length(val),1)
                % then length iseven, add one more
                val = [val,val(end)+obj.resolutionXY];
            end
        end
        
        function val = get.zvect(obj)
            if length(obj.zrange) == 2
                val = obj.zrange(1):obj.resolutionZ:obj.zrange(2);
            else
                % user provided z-vector specifying positions
                val = unique(obj.zrange);
            end
        end
        
        function val = get.centerY(obj)
           val = (length(obj.yvect)+1)/2;
        end
        
        function val = get.centerX(obj)
            val = (length(obj.xvect)+1)/2;
        end
                        
        function obj = calcKernels(obj)
            % gen grids / init results
            obj.Results = heatSimResults.container(obj);
            % but only calc half y domain bc of symmetry
            [Xgrid_h,Ygrid_h,Zgrid_h] = meshgrid(obj.xvect,obj.yvect(1:1+(length(obj.yvect)-1)/2),obj.zvect);
            len = numel(Xgrid_h);
            % init kernel cell array
            obj.kernel = cell(length(obj.vfeed),1);
            
            switch obj.heatSourceType
                case 'point'
                    if any(obj.zvect == 0)
                        warning('Point source yields singularities at surface! It is not reommended to evaluate results at z = 0. Use "gaussian".')
                    end
                    radius = sqrt(Xgrid_h.^2 + Ygrid_h.^2 + Zgrid_h.^2);
                    for k = 1:length(obj.vfeed)
                        kernel_current = 1./(2*pi.*radius*obj.material.kappa) .* exp((-obj.vfeed(k).*(radius+Xgrid_h))./(2*obj.material.kappa));
                        % generate full domain (symmetry)
                        obj.kernel{k} = [kernel_current(:,:,:); flip(kernel_current(1:end-1,:,:),1)];
                    end
                    
                case 'gaussian'
                    % set fundamental radius to half resolution, avoids singularities due to pt source
                    R = obj.resolutionXY/2;
                    % current kernel linear index
                    kernel_current = nan(len,1);
                    % loop over all indices & feedrates
                    for k = 1:length(obj.vfeed)
                        fprintf('Calculating kernels for vfeed = %.1f m/s\n',obj.vfeed(k));
                        for i = 1:len
                            fun = @(time) 1./(pi*(sqrt(pi*obj.material.kappa.*time)) .* (2*R^2 + 4*obj.material.kappa.*time))...
                                .* exp( -(Zgrid_h(i)^2./(4*obj.material.kappa.*time) + ((Xgrid_h(i)+obj.vfeed(k).*time).^2+Ygrid_h(i)^2)./(2*R^2 + 4*obj.material.kappa.*time) ) );
                            kernel_current(i) = integral(fun,0,inf);
                            if ~mod(i,floor(len/15))
                                fprintf('%.1f%%\n',100*i/len);
                            end
                        end
                        % write result then next vfeed
                        tmp = reshape(kernel_current,size(Xgrid_h));
                        % generate full domain (symmetry)
                        obj.kernel{k} = [tmp(:,:,:); flip(tmp(1:end-1,:,:),1)];
                        
                        if length(obj.vfeed) > 1
                            fprintf('\n%i\\%i kernels calculated.\n\n',k,length(obj.vfeed));
                        end
                    end
                    %thermal_modeling1.pdf slide 16-17
                    %fun2 = @(time) 2./(4*pi*obj.material.kappa.*time).^1.5 .* exp( -((Xgrid_h(i)+obj.vfeed(k).*time).^2+Ygrid_h(i)^2+Zgrid_h(i)^2)./(4*obj.material.kappa.*time) );
                    %kernel_alternative = integral(fun2,0,inf); 
            end
            % init heatDistribution
            obj.heatDistrib = heatInputs(obj);
        end
        
        function obj = updateResult(obj)
            if ~obj.kernelsReady
                warning('Kernels not ready. Exiting.')
                return
            end
            tempField = nan(size(obj.kernel{obj.index}));
            for i = 1:length(obj.zvect)
                if exist('inplaceprod','file') == 3
                    tempField(:,:,i) = conv2fft(obj.heatDistrib.intensity,obj.kernel{obj.index}(:,:,i),'same')...
                        .* obj.heatDistrib.validConvolution;
                else
                    tempField(:,:,i) = conv2(obj.heatDistrib.intensity,obj.kernel{obj.index}(:,:,i),'same')...
                        .* obj.heatDistrib.validConvolution;
                end
            end
            finalTempField = tempField .* obj.heatScale;
            obj.Results = obj.Results.update(obj,finalTempField);
        end
        
        function val = get.heatScale(obj)
            % prefactor / scalar outside the integral of cline-anthony equation
            val = obj.power * obj.material.absorptivity / (obj.material.rho * obj.material.cp);
        end
        
        function val = get.heatScalePTsource(obj)
            %val = obj.power * obj.material.absorptivity / (2*pi * obj.material.rho * obj.material.cp * obj.material.kappa);
            val = obj.power;
        end
        
        function obj = reset(obj)
            obj.kernel = {};
        end
        
    end
end

%         function obj = calcKernels(obj)
%             % gen grids
%             [obj.Xgrid,obj.Ygrid,obj.Zgrid] = meshgrid(obj.xvect,obj.yvect,obj.zvect);
%             len = numel(obj.Xgrid);
%             % init kernel cell array
%             obj.kernel = cell(length(obj.vfeed),1);
%             % set fundamental radius to half resolution, avoids singularities due to pt source
%             R = obj.resolutionXY/2; 
%             % current kernel linear index
%             kernel_current = nan(len,1);
%             % loop over all indices & feedrates
%             for k = 1:length(obj.vfeed)
%                 fprintf('Calculating kernels for vfeed = %.1f m/s\n',obj.vfeed(k));
%                 for i = 1:len
%                     fun = @(time) 1./(sqrt(pi*obj.material.kappa.*time) .* (2*R^2 + 4*obj.material.kappa.*time))...
%                         .* exp(- (obj.Zgrid(i)^2./(4*obj.material.kappa.*time) + ((obj.Xgrid(i)+obj.vfeed.*time).^2+obj.Ygrid(i)^2)./(2*R^2 + 4*obj.material.kappa.*time) ) );
%                     kernel_current(i) = integral(fun,0,inf);
%                     
%                     if ~mod(i,floor(len/20))
%                         fprintf('%.1f%%\n',100*i/len);
%                     end
%                 end
%                 % write result then next vfeed
%                 obj.kernel{k} = reshape(kernel_current,size(obj.Xgrid));
%             end
%             % write lateral reference size for heatInputs etc.
%             obj.refSize = size(obj.kernel{1},1:2);
%             % init heatDistribution
%             obj.heatDistrib = heatInputs(obj);
%         end
